# 1. 进程与线程
## 1.1 进程的概念和特征
### 1.1.1 进程的概念
在多道程序环境下，允许多个程序并发执行，此时他们将失去封闭性，并具有间断性和不可再现的特性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性
为了使参与并发执行的每个程序(数据块)都能独立的运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block，PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应的，由程序段、相关数据段和PCB三部分构成了**进程实体**。所谓创建进程，就是创建进程的PCB；而撤销进程，就是撤销进程的PCB
### 1.1.2 进程的定义
1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集上执行的过程，它是系统进行资源分配和调度的一个基本单位
### 1.1.3 进程的特征
1. 动态性
2. 并发性
3. 独立性
4. 异步性
## 1.2 进程的组成
1. 进程控制块
	1. 生命周期
		1. 进程创建时，操作系统为进程创建一个新的PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一个部分，时进程存在的唯一标志、
		2. 进程进行时，系统通过其PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统回收其PCB，该进程随之消亡
		3. 当操作系统希望调度某个进程运行时，要从该进程的PCB中查出其现行状态及优先级;在调度到某个进程后，要根据其PCB中所保存的CPU状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据;进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB;当进程由于某种原因而暂停运行时，又需将其断点的 CPU环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在
	2. PCB的组成
		1. **进程描述信息**。进程标识符,标志各个进程，每个进程都有一个唯一的标识号。用户标识符，进程所归属的用户，用户标识符主要为共享和保护服务。
		2. **进程控制和管理信息**。进程当前状态;描述进程的状态信息，作为CPU分配调度的依据进程优先级:描述进程抢占CPU的优先级，优先级高的进程可优先获得CPU。
		3. **资源分配清单**，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。
		4. **处理机相关信息**，也称CPU的上下文，主要指CPU中各寄存器的值。当进程处于执行态时，CPU的许多信息都在寄存器中。当进程被切换时，CPU状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。
2. 程序段
	程序段就是能被进程调度程序调度到CPU执行的程序代码段。程序被多个进程共享，即多个进程可以同时运行同一个程序
3. 数据段
	一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果
### 1.2.1 进程的状态与转换
1. 运行态。进程正在CPU上运行。在单CPU中，每个时刻只有一个进程处于运行态。
2. 就绪态。进程获得了除CPU外的一切所需资源，一旦得到CPU，便可立即运行。系统中处于就绪态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。
3. 阻塞态，又称等待态。进程正在等待某一事件而停运行，如等待某个资源可用(不包括CPU)或等待IO完成。即使CPU空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。
4. 创建态。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤:首先申请一个空自PCB，并向PCB中填写用于控制和管理进程的信息;然后为该进程分配运行时所必须的资源;最后将该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态
5. 终止态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。
### 1.2.2 进程控制
1. 进程的创建
	1. 父进程与子进程的关系和特点
		允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时,应将其从父进程那里获得的资源还给父进程，此外，在撤销父进程时，通常也会同时撤销其所有的子进程。
	2. 导致创建进程的操作 
		在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下(创建原语)
	3. 创建新进程时的操作
		1. 为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB 是有限的)。若PCB申请失败，则创建失败。
		2. 为进程分配其运行所需的资源，如内存、文件、IO设备和CPU时间等(在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足(如内存)，则并不是创建失败，而是处于创建态，等待内存资源。
		3. 初始化 PCB，主要包括初始化标志信息、初始化 CPU 状态信息和初始化 CPU 控制信息以及设咒进程的优先级等。
		4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。
2. 进程的终止
	1. 正常结束，表示进程的任务已完成并准备退出运行。
	2. 异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、IO故障等。
	3. 外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。
3. 终止进程时的操作
	操作系统终止进程的过程如下(终止原语)
	1. 根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。
	2. 若被终止进程处于运行状态，立即终止该进程的执行，将CPU资源分配给其他进程
	3. 若该进程还有子孙进程，则通常需将其所有子孙进程终止(有些系统无此要求)。
	4. 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
	5. 将该PCB从所在队列(链表)中删除。
4. 进程的阻塞和唤醒
	1. 进程阻塞的事件与时机
		正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语(Block)，使自己由运行态变为阳塞态。可见，阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞态。阻塞原语的执行过程如下:
		1. 找到将要被阻塞进程的标识号(PID)对应的PCB
		2. 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行
		3. 将该PCB插入相应事件的等待队列，将CPU资源调度给其他就绪进程
	2. 进程唤醒的事件与时机
		当被阻塞进程所期待的事件出现时,如它所期待的IO操作已完成或其所期待的数据已到达,由有关进程(比如，释放该IO设备的进程，或提供数据的进程)调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。唤醒原语的执行过程如下:
		1. 在该事件的等待队列中找到相应进程的PCB。
		2. 将其从等待队列中移出，并置其状态为就绪态
		3. 将该PCB插入就绪队列，等待调度程序调度。
	3. 应当注意，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。如果在某个进程中调用了 Block原语,则必须在与之合作的或其他相关的进程中安排一条相应的 Wakeup原语，以便唤醒阻塞进程;否则，阻塞进程将因不能被唤醒而永久地处于阻塞态
### 1.2.3 进程的通信
1. 共享存储
	在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具(如P操作、V操作)对共享空间的写/读进行控制
	**低级方式的共享**是基于数据结构的共享
	**高级方式的共享**则是基于存储区的共享
	操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。
2. 消息传递
	若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。
	在消息传递系统中，进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的发送消息和接收消息两个原语进行数据交换。
3. 管道通信
	管道是一个特殊的共享文件，又称pipe文件，数据在管道中是先进先出的。管道通信允许两个进程按生产者-消费者方式进行通信，只要管道不满,写进程就能向管道的一端写入数据:只要管道非空，读进程就能从管道的一端读出数据。为了协调双方的通信，管道机制必须提供三方面的协调能力:
	1. 互斥,指当一个进程对管道进行读/写操作时，其他进程必须等待。
	2. 同步，指写进程向管道写入一定数量的数据后，写进程阻塞，直到读进程取走数据后再将它唤醒。读进程将管道中的数据取空后，读进程阻塞，直到写进程将数据写入管道后才将其唤醒。
	3. 确定对方的存在
4. linux管道 
	在Linux 中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下
	1. 限制管道的大小。管道文件是一个固定大小的缓冲区，在Linux中该缓冲区的大小为4KB，这使得它的大小不像普通文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。
	2. 读进程也可能工作得比写进程快。当管道内的数据已被读取时，管道变空。当这种情况发生时，一个随后的readO调用将被阻塞，等待某些数据的写入。
	3. 管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并可用它来与父进程进行通信。
> 从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。普通管道只允许单向通信，若要实现两个进程双向通信，则需要定义两个管道。

## 1.3多线程
### 1.3.1 线程与进程的比较
1. 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程切换。但从个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
2. 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。
3. 拥有资源。进程是系统中拥有资源的基本单位，而线程不拥有系统资源(仅有一点必不可少、能保证独立运行的资源)，但线程可以访问其隶属进程的系统资源，这主要表现在属于同一进程的所有线程都具有相同的地址空间。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。
4. 独立性。每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某个进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。
5. 系统开销。在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源如内存空间、IO设备等。操作系统为此所付出的开销，明显大于创建或撤销线程时的开销。类似地，在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。
6. 支持多处理器系统。对于传统单线程进程，不管有多少个CPU,进程只能运行在一个CPU上。对于多线程进程，可将进程中的多个线程分配到多个CPU上执行。
# 2. CPU调度
## 2.1 调度的概念
### 2.1.1 调度的基本概念
在多道程序系统中,进程的数量往往多于CPU的个数,因此进程争用CPU的情况在所难CPU 调度是对CPU进行分配，即从就绪队列中按照一定的算法(公平、高效的原则)选择一个进程并将 CPU 分配给它运行，以实现进程并发地执行。
### 2.1.2 调度的层次
1. 高级调度(作业调度)
	按照某种规则从外存上处于后备队列的作业中挑选一个(或多个)，给它(们)分配内存、IO设备等必要的资源，并建立相应的进程，以使它(们)获得竞争CPU的权利。简言之，作业调度就是内存与辅存之间的调度。每个作业只调入一次、调出一次。
	多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。
2. 中级调度(内存调度)
	引入中级调度的目的是提高内存利用率和系统吞吐量。为此，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定将外存上的那些已具备运行条件的挂起进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。中级调度实际上是存储器管理中的对换功能。
3. 低级调度(进程调度)
	按照某种算法从就绪队列中选取一个进程，将CPU分配给它。进程调度是最基本的一种调度，在各种操作系统中都必须配置这级调度。进程调度的频率很高，一般几十毫秒一次。
## 2.2 调度的实现
### 2.2.1 调度程序
1. 排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入相应的就绪队列。
2. 分派器。依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。
3. 上下文切换器。在对CPU进行切换时，会发生两对上下文的切换操作:第一对，将当前进程的上下文保存到其 PCB 中，再装入分派程序的上下文，以便分派程序运行;第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入CPU的各个相应寄存器。
在上下文切换时，需要执行大量1oad和store指令，以保存寄存器的内容，因此会花费较多时间。现在已有硬件实现的方法来减少上下文切换时间。通常采用两组寄存器，其中一组供内核使用，一组供用户使用。这样，上下文切换时，只需改变指针，让其指向当前寄存器组即可。
### 2.2.2 调度的时机、切换与过程
调度程序是操作系统内核程序。请求调度的事件发生后，才可能运行调度程序，调度了新的就绪进程后，才会进行进程切换。理论上这三件事情应该顺序执行，但在实际的操作系统内核程序运行中，若某时刻发生了引起进程调度的因素，则不一定能马上进行调度与切换。
现代操作系统中，应该进行进程调度与切换的情况如下:
1. 创建新进程后，由于父进程和子进程都处于就绪态，因此需要决定是运行父进程还是运行子进程，调度程序可以合法地决定其中一个进程先运行。
2. 进程正常结束后或者异常终止后，必须从就绪队列中选择某个进程运行。若没有就绪进程，则通常运行一个系统提供的闲逛进程。
3. 当进程因IO请求、信号量操作或其他原因而被阻塞时，必须调度其他进程运行。
4. 当IO设备完成后，发出IO中断，原先等待IO的进程从阻塞态变为就绪态，此时需要决定是让新的就绪进程投入运行，还是让中断发生时运行的进程继续执行。

不能进行进程的调度与切换的情况如下:
1. 在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺CPU 资源。
2. 需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。
### 2.2.3 进程调度的方式
1. 非抢占调度方式，又称非剥夺方式。是指当一个进程正在CPU上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程运行完成(如正常结束、异常终止)或发生某种事件(如等待O操作、在进程通信或同步中执行了 Block 原语)而进入阻塞态时，才将CPU分配给其他进程。非抢占调度方式的优点是实现简单、系统开销小，适用于早期的批处理系统，但它不能用于分时系统和大多数的实时系统。
2. 抢占调度方式，又称剥夺方式。是指当一个进程正在CPU上执行时，若有某个更为重要或紧迫的进程需要使用CPU，则允许调度程序根据某种原则去暂停正在执行的进程，将CPU分配给这个更为重要或紧迫的进程。
抢占调度方式对提高系统吞吐率和响应效率都有明显的好处。但“抢占”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。
### 2.2.4 闲逛进程
在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(IdleProcess)运行，它的PI为0。如果没有其他进程就绪，该进程就一直运行，并在指令周期后测试中断。闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出CPU。闲逛进程不需要 CPU之外的资源，它不会被阻塞。
### 2.2.5 两种线程的调度
1. 用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。
2. 内核级线程调度。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。
用户级线程的线程切换在同一进程中进行，仅需少量的机器指令;内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。
## 2.3 进程调度的目标
1. CPU利用率
2. 系统吞吐量
3. 周转时间
4. 等待时间
5. 响应时间
### 2.4 进程切换
对于通常的进程而言，其创建、撤销及要求由系统设备完成的IO操作，都是利用系统调用而进入内核，再由内核中的相应处理程序子以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
1. 上下文切换
	切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为上下文切换。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等当进行上下文切换时，内核将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。在切换过程中，进程的运行环境产生实质性的变化。上下文切换的流程如下:
	1. 挂起一个进程，将CPU上下文保存到PCB，包括程序计数器和其他寄存器。
	2. 将进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。
	3. 选择另一个进程执行，并更新其PCB。
	4. 恢复新进程的 CPU 上下文。
	5. 跳转到新进程 PCB 中的程序计数器所指向的位置执行。
2. 上下文切换的消耗
	上下文切换通常是计算密集型的，即它需要相当可观的CPU时间，在每秒几十上百次的切换中,每次切换都需要纳秒量级的时间,所以上下文切换对系统来说意味着消耗大量的CPU时间。有些CPU提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针。
3. 上下文切换与模式切换
	模式切换与上下文切换是不同的，模式切换时，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。
## 2.5 经典算法
1. 先来先服务
2. 短作业优先
3. 高响应比优先
4. 优先级调度
5. 时间片轮转
6. 多级队列调度
7. 多级反馈队列调度
# 3. 同步与互斥
## 3.1 同步与互斥的基本概念
## 3.1.1 临界资源
一次仅允许一个进程使用的资源称为临界资源
对临界资源的访问，必须互斥地进行，在每个进程中,访问临界资源的那段代码称为临界区为了保证临界资源的正确使用，可将临界资源的访问过程分成4个部分:
1. 进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区
2. 临界区。进程中访问临界资源的那段代码，又称临界段。
3. 退出区。将正在访问临界区的标志清除。
4. 剩余区。代码中的其余部分。
### 3.1.2 同步
同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要协调它们的运行次序而等待、传递信息所产生的制约关系。同步关系源于进程之间的相互合作。
例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程 A 将数据送入缓冲区，进程B就被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程 B取走缓冲数据时，才唤醒进程A。
### 3.1.3 互斥
互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。
例如，在仅有一台打印机的系统中，有两个进程A和进程B，若当进程A需要打印时，系统已将打印机分配给进程B，则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞态变为就绪态。
### 3.1.4 必须实现的准则
1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区，防止进程无限等待
4. 让权等待(原则上应该遵循，但非必须)。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。
## 3.2 实现临界区互斥的基本方法
### 3.2.1 软件实现方式
#### 3.2.1.1 单标志法
该算法设置一个公用整型变量turn，指示允许进入临界区的进程编号，当turn=0时，表示允许P0 进入临界区:当tum=1时，表示允许P1进入临界区。进程退出临界区时将临界区的使用权赋给另一个进程，当Pi退出临界区时，将turn置为j(i=0、j=1或i=1、j=0)
#### 3.2.1.2 双标志先检查法
#### 3.2.1.3 双标志后检查法
#### 3.2.1.4 Peterson算法
Peterson 算法结合了算法一和算法三的思想，利用 flag[]解决互斥访问问题，而利用 tum 解决“饥饿”问题。若双方都争着进入临界区，则可让进程将进入临界区的机会谦让给对方。也就是说，在每个进程进入临界区之前，先设置自己的nag标志，再设置允许进入tum 标志;之后，再同时检测对方的fag和turn 标志，以保证双方同时要求进入临界区时，只允许一个进程进入。
### 3.2.2 硬件实现方式
#### 3.2.2.1 中断屏蔽方法
当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简单方法是关中断。因为 CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。
缺点：
1. 限制了CPU 交替执行程序的能力，因此系统效率会明显降低。
2. 对内核来说，在它执行更新变量的几条指令期间，关中断是很方便的，但将关中断的权限交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。
3. 不适用于多处理器系统因为在一个 CPU上关中断并不能防止进程在其他CPU 上执行相同的临界区代码。
#### 3.2.2.2 TestAndSet指令
借助一条硬件指令--TestAndset 指令(简称TS指令)实现互斥，这条指令是原子操作其功能是读出指定标志后将该标志设置为真。
当用TS指令管理临界区时，为每个临界资源设置一个共享布尔变量lock，表示该资源的两种状态:true表示正被占用(已加锁);false表示空闲(未加锁)，初值为false，所以可将lock 视为一把锁。进程在进入临界区之前，先用TS指令检査lock 值:
1. 若为false，则表示没有进程在临界区，可以进入，并将lock置为true，这意味着关闭了临界资源(加锁)，使任何进程都不能进入临界区;
2. 若为 true，则表示有进程在临界区中，进入循环等待，直到当前访问临界区的进程退出时解锁(将lock 置为false)。
#### 3.2.2.3 Swap指令
Swap指令的功能是交换两个字(字节)的内容
用Swap指令管理临界区时，为每个临界资源设置一个共享布尔变量lock，初值为false;在每个进程中再设置一个局部布尔变量key,初值为true,用于与lock交换信息。从逻辑上看，Swap指令和TS指令实现互斥的方法并无太大区别，都先记录此时临界区是否已加锁(记录在变量key中)，再将锁标志lock置为true，最后检查key，若key为false，则说明之前没有其他进程对临界区加锁，于是跳出循环，进入临界区。
优点：
1. 简单、容易验证其正确性
2. 适用于任意数目的进程,支持多处理器系统
3. 支持系统中有多个临界区，只需为每个临界区设立一个布尔变量
缺点：
1. 等待进入临界区的进程会占用 CPU执行 while 循环，不能实现“让权等待”
2. 从等待进程中随机选择一个进程进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。
### 3.2.3互斥锁
解决临界区最简单的工具就是互斥锁(mutexlock)。一个进程在进入临界区时调用 acquire()函数，以获得锁;在退出临界区时调用release()函数，以释放锁。每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。
### 3.2.4 信号量
信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语waitO)和 signalO访问，也可简写为 PO和 VO，或者简称P操作和V操作。
#### 3.2.4.1 整型信号量
整型信号量被定义为一个用于表示资源数目的整型量S，相比于普通整型变量，对整型信号量的操作只有三种:初始化、wait操作和signal操作。
#### 3.2.4.2 记录型信号量
记录型信号量机制是一种不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。
## 3.3 经典问题
### 3.3.1 生产者消费者问题
### 3.3.2 读者-写者问题
### 3.3.3 吸烟者问题
### 3.3.4 哲学家进餐问题
## 3.4 管程机制
利用共享数据结构抽象地表示系统中的共享资源,而将对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程(monitor)。
管程由4部分组成:
1. 管程的名称                                                                                                     类名
2. 局部于管程内部的共享数据结构说明                                              内部变量
3. 对该数据结构进行操作的一组过程(或函数)                                 方法
4. 对局部于管程内部的共享数据设置初始值的语句                     init
# 4 死锁
## 4.1 死锁的概念
### 4.1.1 死锁的定义
在多道程序系统中，由于进程的并发执行，极大提升了系统效率。然而，多个进程的并发执行也带来了新的问题--死锁。所谓死锁，是指多个进程因竞争资源而造成的一种僵局(互相等待对方手里的资源)，使得各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进。
### 4.1.2 死锁与饥饿
一组进程处于死锁状态是指组内的每个进程都在等待一个事件，而该事件只可能由组内的另一个进程产生。与死锁相关的另一个问题是饥饿，即进程在信号量内无穷等待的情况。
产生饥饿的主要原因是:当系统中有多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序，有的分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统未发生死锁，某些进程也可能长时间等待。当等待时间给进程的推进带来明显影响时，称发生了饥饿。
主要差别
1. 发生饥饿的进程可以只有一个;而死锁是因循环等待对方手里的资源而导致的，因此，如果有死锁现象，那么发生死锁的进程必然大于或等于两个。
2. 发生饥饿的进程可能处于就绪态(长期得不到CPU，如SIF 算法的问题)，也可能处于阻塞态(如长期得不到所需的 IO 设备，如上述举例);而发生死锁的进程必定处于阻塞态。
### 4.1.3 死锁产生的原因
#### 4.1.3.1 系统资源的竞争
通常系统中拥有的不可剥夺资源(如磁带机、打印机等)，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源(如CPU和主存)的竞争是不会引起死锁的。
#### 4.1.3.2 进程推进顺序非法
请求和释放资源的顺序不当，也同样会导致死锁。例如，进程P,P分别保持了资源R,R而P申请资源R、P,申请资源R,时，两者都会因为所需资源被占用而阻塞，于是导致死锁。信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，也会使得这些进程无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。
### 4.1.4 死锁产生的必要条件
1. 互斥条件。进程要求对所分配的资源(如打印机)进行排他性使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
2. 不可剥夺条件。进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)。
3. 请求并保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4. 循环等待条件。存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

### 4.1.5 死锁的处理策略
为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。
1. 死锁预防。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。
2. 避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。
3. 死锁的检测及解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。
