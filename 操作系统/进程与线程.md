# 1. 进程与线程
# 1.1 进程的概念和特征
### 1.1.1 进程的概念
在多道程序环境下，允许多个程序并发执行，此时他们将失去封闭性，并具有间断性和不可再现的特性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性
为了使参与并发执行的每个程序(数据块)都能独立的运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block，PCB)。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应的，由程序段、相关数据段和PCB三部分构成了**进程实体**。所谓创建进程，就是创建进程的PCB；而撤销进程，就是撤销进程的PCB
### 1.1.2 进程的定义
1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集上执行的过程，它是系统进行资源分配和调度的一个基本单位
### 1.1.3 进程的特征
1. 动态性
2. 并发性
3. 独立性
4. 异步性
## 1.2 进程的组成
1. 进程控制块
	1. 生命周期
		1. 进程创建时，操作系统为进程创建一个新的PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一个部分，时进程存在的唯一标志、
		2. 进程进行时，系统通过其PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统回收其PCB，该进程随之消亡
		3. 当操作系统希望调度某个进程运行时，要从该进程的PCB中查出其现行状态及优先级;在调度到某个进程后，要根据其PCB中所保存的CPU状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据;进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB;当进程由于某种原因而暂停运行时，又需将其断点的 CPU环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在
	2. PCB的组成
		1. **进程描述信息**。进程标识符,标志各个进程，每个进程都有一个唯一的标识号。用户标识符，进程所归属的用户，用户标识符主要为共享和保护服务。
		2. **进程控制和管理信息**。进程当前状态;描述进程的状态信息，作为CPU分配调度的依据进程优先级:描述进程抢占CPU的优先级，优先级高的进程可优先获得CPU。
		3. **资源分配清单**，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。
		4. **处理机相关信息**，也称CPU的上下文，主要指CPU中各寄存器的值。当进程处于执行态时，CPU的许多信息都在寄存器中。当进程被切换时，CPU状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。
2. 程序段
	程序段就是能被进程调度程序调度到CPU执行的程序代码段。程序被多个进程共享，即多个进程可以同时运行同一个程序
3. 数据段
	一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果
### 1.2.1 进程的状态与转换
1. 运行态。进程正在CPU上运行。在单CPU中，每个时刻只有一个进程处于运行态。
2. 就绪态。进程获得了除CPU外的一切所需资源，一旦得到CPU，便可立即运行。系统中处于就绪态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。
3. 阻塞态，又称等待态。进程正在等待某一事件而停运行，如等待某个资源可用(不包括CPU)或等待IO完成。即使CPU空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。
4. 创建态。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤:首先申请一个空自PCB，并向PCB中填写用于控制和管理进程的信息;然后为该进程分配运行时所必须的资源;最后将该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态
5. 终止态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。
### 1.2.2 进程控制
1. 进程的创建
	1. 父进程与子进程的关系和特点
		允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时,应将其从父进程那里获得的资源还给父进程，此外，在撤销父进程时，通常也会同时撤销其所有的子进程。
	2. 导致创建进程的操作 
		在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下(创建原语)
	3. 创建新进程时的操作
		1. 为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB 是有限的)。若PCB申请失败，则创建失败。
		2. 为进程分配其运行所需的资源，如内存、文件、IO设备和CPU时间等(在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足(如内存)，则并不是创建失败，而是处于创建态，等待内存资源。
		3. 初始化 PCB，主要包括初始化标志信息、初始化 CPU 状态信息和初始化 CPU 控制信息以及设咒进程的优先级等。
		4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。
2. 进程的终止
	1. 正常结束，表示进程的任务已完成并准备退出运行。
	2. 异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、IO故障等。
	3. 外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。
3. 终止进程时的操作
	操作系统终止进程的过程如下(终止原语)
	1. 根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。
	2. 若被终止进程处于运行状态，立即终止该进程的执行，将CPU资源分配给其他进程
	3. 若该进程还有子孙进程，则通常需将其所有子孙进程终止(有些系统无此要求)。
	4. 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
	5. 将该PCB从所在队列(链表)中删除。
4. 进程的阻塞和唤醒
	1. 进程阻塞的事件与时机
		正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语(Block)，使自己由运行态变为阳塞态。可见，阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞态。阻塞原语的执行过程如下:
		1. 找到将要被阻塞进程的标识号(PID)对应的PCB
		2. 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行
		3. 将该PCB插入相应事件的等待队列，将CPU资源调度给其他就绪进程
	2. 进程唤醒的事件与时机
		当被阻塞进程所期待的事件出现时,如它所期待的IO操作已完成或其所期待的数据已到达,由有关进程(比如，释放该IO设备的进程，或提供数据的进程)调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。唤醒原语的执行过程如下:
		1. 在该事件的等待队列中找到相应进程的PCB。
		2. 将其从等待队列中移出，并置其状态为就绪态
		3. 将该PCB插入就绪队列，等待调度程序调度。
	3. 应当注意，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。如果在某个进程中调用了 Block原语,则必须在与之合作的或其他相关的进程中安排一条相应的 Wakeup原语，以便唤醒阻塞进程;否则，阻塞进程将因不能被唤醒而永久地处于阻塞态
### 1.2.3 进程的通信
1. 共享存储
	在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具(如P操作、V操作)对共享空间的写/读进行控制
	**低级方式的共享**是基于数据结构的共享
	**高级方式的共享**则是基于存储区的共享
	操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。
2. 消息传递
	若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。
	在消息传递系统中，进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的发送消息和接收消息两个原语进行数据交换。
3. 管道通信
	管道是一个特殊的共享文件，又称pipe文件，数据在管道中是先进先出的。管道通信允许两个进程按生产者-消费者方式进行通信，只要管道不满,写进程就能向管道的一端写入数据:只要管道非空，读进程就能从管道的一端读出数据。为了协调双方的通信，管道机制必须提供三方面的协调能力:
	1. 互斥,指当一个进程对管道进行读/写操作时，其他进程必须等待。
	2. 同步，指写进程向管道写入一定数量的数据后，写进程阻塞，直到读进程取走数据后再将它唤醒。读进程将管道中的数据取空后，读进程阻塞，直到写进程将数据写入管道后才将其唤醒。
	3. 确定对方的存在
4. linux管道 
	在Linux 中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下
	1. 限制管道的大小。管道文件是一个固定大小的缓冲区，在Linux中该缓冲区的大小为4KB，这使得它的大小不像普通文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用。
	2. 读进程也可能工作得比写进程快。当管道内的数据已被读取时，管道变空。当这种情况发生时，一个随后的readO调用将被阻塞，等待某些数据的写入。
	3. 管道只能由创建进程所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并可用它来与父进程进行通信。
> 从管道读数据是一次性操作，数据一旦被读取，就释放空间以便写更多数据。普通管道只允许单向通信，若要实现两个进程双向通信，则需要定义两个管道。

## 1.3多线程
### 1.3.1 线程与进程的比较
1. 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程切换。但从个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
2. 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。
3. 拥有资源。进程是系统中拥有资源的基本单位，而线程不拥有系统资源(仅有一点必不可少、能保证独立运行的资源)，但线程可以访问其隶属进程的系统资源，这主要表现在属于同一进程的所有线程都具有相同的地址空间。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。
4. 独立性。每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某个进程中的线程对其他进程不可见。同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。
5. 系统开销。在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源如内存空间、IO设备等。操作系统为此所付出的开销，明显大于创建或撤销线程时的开销。类似地，在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。
6. 支持多处理器系统。对于传统单线程进程，不管有多少个CPU,进程只能运行在一个CPU上。对于多线程进程，可将进程中的多个线程分配到多个CPU上执行。
# 2. CPU调度
## 2.1 调度的概念
### 2.1.1 调度的基本概念
在多道程序系统中,进程的数量往往多于CPU的个数,因此进程争用CPU的情况在所难CPU 调度是对CPU进行分配，即从就绪队列中按照一定的算法(公平、高效的原则)选择一个进程并将 CPU 分配给它运行，以实现进程并发地执行。
### 2.1.2 调度的层次
1. 高级调度(作业调度)
	按照某种规则从外存上处于后备队列的作业中挑选一个(或多个)，给它(们)分配内存、IO设备等必要的资源，并建立相应的进程，以使它(们)获得竞争CPU的权利。简言之，作业调度就是内存与辅存之间的调度。每个作业只调入一次、调出一次。
	多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。
2. 中级调度(内存调度)
	引入中级调度的目的是提高内存利用率和系统吞吐量。为此，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定将外存上的那些已具备运行条件的挂起进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。中级调度实际上是存储器管理中的对换功能。
3. 低级调度(进程调度)
	按照某种算法从就绪队列中选取一个进程，将CPU分配给它。进程调度是最基本的一种调度，在各种操作系统中都必须配置这级调度。进程调度的频率很高，一般几十毫秒一次。
## 2.2 调度的实现
### 2.2.1 调度程序
1. 排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入相应的就绪队列。
2. 分派器。依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。
3. 上下文切换器。在对CPU进行切换时，会发生两对上下文的切换操作:第一对，将当前进程的上下文保存到其 PCB 中，再装入分派程序的上下文，以便分派程序运行;第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入CPU的各个相应寄存器。
在上下文切换时，需要执行大量1oad和store指令，以保存寄存器的内容，因此会花费较多时间。现在已有硬件实现的方法来减少上下文切换时间。通常采用两组寄存器，其中一组供内核使用，一组供用户使用。这样，上下文切换时，只需改变指针，让其指向当前寄存器组即可。
### 2.2.2 调度的时机、切换与过程
调度程序是操作系统内核程序。请求调度的事件发生后，才可能运行调度程序，调度了新的就绪进程后，才会进行进程切换。理论上这三件事情应该顺序执行，但在实际的操作系统内核程序运行中，若某时刻发生了引起进程调度的因素，则不一定能马上进行调度与切换。
现代操作系统中，应该进行进程调度与切换的情况如下:
1. 创建新进程后，由于父进程和子进程都处于就绪态，因此需要决定是运行父进程还是运行子进程，调度程序可以合法地决定其中一个进程先运行。
2. 进程正常结束后或者异常终止后，必须从就绪队列中选择某个进程运行。若没有就绪进程，则通常运行一个系统提供的闲逛进程。
3. 当进程因IO请求、信号量操作或其他原因而被阻塞时，必须调度其他进程运行。
4. 当IO设备完成后，发出IO中断，原先等待IO的进程从阻塞态变为就绪态，此时需要决定是让新的就绪进程投入运行，还是让中断发生时运行的进程继续执行。

不能进行进程的调度与切换的情况如下:
1. 在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺CPU 资源。
2. 需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。
### 2.2.3 进程调度的方式
1. 非抢占调度方式，又称非剥夺方式。是指当一个进程正在CPU上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程运行完成(如正常结束、异常终止)或发生某种事件(如等待O操作、在进程通信或同步中执行了 Block 原语)而进入阻塞态时，才将CPU分配给其他进程。非抢占调度方式的优点是实现简单、系统开销小，适用于早期的批处理系统，但它不能用于分时系统和大多数的实时系统。
2. 抢占调度方式，又称剥夺方式。是指当一个进程正在CPU上执行时，若有某个更为重要或紧迫的进程需要使用CPU，则允许调度程序根据某种原则去暂停正在执行的进程，将CPU分配给这个更为重要或紧迫的进程。
抢占调度方式对提高系统吞吐率和响应效率都有明显的好处。但“抢占”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。
### 2.2.4 闲逛进程
在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(IdleProcess)运行，它的PI为0。如果没有其他进程就绪，该进程就一直运行，并在指令周期后测试中断。闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出CPU。闲逛进程不需要 CPU之外的资源，它不会被阻塞。
### 2.2.5 两种线程的调度
1. 用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。
2. 内核级线程调度。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。
用户级线程的线程切换在同一进程中进行，仅需少量的机器指令;内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。
## 2.3 进程调度的目标
1. CPU利用率
2. 系统吞吐量
3. 周转时间
4. 等待时间
5. 响应时间
### 2.4 进程切换
对于通常的进程而言，其创建、撤销及要求由系统设备完成的IO操作，都是利用系统调用而进入内核，再由内核中的相应处理程序子以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
1. 上下文切换
	切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为上下文切换。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等当进行上下文切换时，内核将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。在切换过程中，进程的运行环境产生实质性的变化。上下文切换的流程如下:
	1. 挂起一个进程，将CPU上下文保存到PCB，包括程序计数器和其他寄存器。
	2. 将进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。
	3. 选择另一个进程执行，并更新其PCB。
	4. 恢复新进程的 CPU 上下文。
	5. 跳转到新进程 PCB 中的程序计数器所指向的位置执行。
2. 上下文切换的消耗
	上下文切换通常是计算密集型的，即它需要相当可观的CPU时间，在每秒几十上百次的切换中,每次切换都需要纳秒量级的时间,所以上下文切换对系统来说意味着消耗大量的CPU时间。有些CPU提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针。
3. 上下文切换与模式切换
	模式切换与上下文切换是不同的，模式切换时，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。
## 2.5 经典算法
1. 先来先服务
2. 短作业优先
3. 高响应比优先
4. 优先级调度
5. 时间片轮转
6. 多级队列调度
7. 多级反馈队列调度